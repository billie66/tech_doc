### du command 
You can use _du_ command in linux system to check the size of a file, or files 
size in a directory.    

    billie@billie-ThinkPad:/boot$ du -h
    16K ./grub/locale
    1.6M    ./grub
    121M    .

The option `-h` means printing sizes in human readable format. The above
command listed the total size of the current directory with its subdirectories 
size respectively. 

You can read man pages to get more usage of _du_. A website about the examples
of [du command][1].

[1]: http://www.labtestproject.com/linuxcmd/du_command.html

### check file type

Use _file_ command to get a file type. 

    billie@billie-ThinkPad:/$ file initrd.img
    initrd.img: symbolic link to `boot/initrd.img-2.6.35-28-generic'

### df command

check the file system disk space usage
    
    billie@~$ df
    Filesystem           1K-blocks      Used Available Use% Mounted on
    /dev/sda6             48060296   8326856  37292072  19% /
    none                    984616       304    984312   1% /dev
    none                    992440     20960    971480   3% /dev/shm
    none                    992440        96    992344   1% /var/run
    none                    992440         0    992440   0% /var/lock
    /dev/sda7             75512952   1250540  70426508   2% /home
    billie@~$ df /home
    Filesystem           1K-blocks      Used Available Use% Mounted on
    /dev/sda7             75512952   1250540  70426508   2% /home

### type command

type, will help you know if a command, is an alias, a built-in command or an
independent command installed in your PC.

    billie@~$ type type
    type is a shell builtin
    billie@~$ type -a ls
    ls is aliased to `ls --color=auto'
    ls is /bin/ls
    billie@~$

If the `-a` option is used, type returns all of the places that contain an
executable named file. This includes aliases and functions, if and only if the
`-p` option is not also used.
        
### tr command
    
Convert doc text file to unix.

    tr "\r" " " <doc >temp
    sed -n "s/ $//p" <temp >unix
    rm temp 
    
### how to check the version of ubuntu installed

    billie@~$ lsb_release -a
    No LSB modules are available.
    Distributor ID: Ubuntu
    Description:    Ubuntu 10.10
    Release:    10.10
    Codename:   maverick
    billie@~$ 

Also, you can view the file `/etc/lsb-release`, or through `system->about ubuntu`

### find command

I want to read the source code of the _mutt_ mail client, so I need _ctags_ to
ease the viewing process. First I should get all the `.h` and `.c` files in
the directory of mutt source code, then use the files as _ctags_ arguments, so 
I run the following command in terminal.

    find -name "*.[ch]" -exec ctags '{}' \;

But when I check the file named `tags` which was generated by _ctags_, it only
includes few symbols about the file named `attach.h`. I feel so surprised. Why
ctags only build `tags` file according to a file? The I try to execute the
below command, which uses `{} +` instead of `'{} \;`.

    find -name "*.[ch]" -exec ctags {} +

Good, I get the exact result, the _ctags_ dealt with all the files. What's the
difference between the two commands. It's easy to know from the command
format. What are the real meaning of the two commands? The first one means
" run `ctags` on every file in the output of `find` command ". The times of
invoking `ctags` is as many as the number of files. So every time _ctags_ 
processes a file, the result will overwrite `tags` file. The second command 
runs `ctags` only once with all files as its arguments.

    find -name "*.[ch]" | xargs ctags

The above command, we call it the third one. It has the same effect as the
second one. If you think the second is not easy to understand, you can use the
third to replace it. 

In additional, if you want to omit some files in a subdirectory, you can use
the command below. I use _mutt_ repository as an example. 

    dir=~/mutt-1.5.21
    find $dir -path "$dir/m4" -prune -o -path "$dir/doc" -prune -o -name "*.[ch]" | xargs ctags 

In the above command, it omit the files in two directories, `m4` and `doc`.

### tar command 

I will use a simple example to explain how to create or extract files from a tarball.
    
    billie@billie-ThinkPad:~/mutt$ ls
    mutt-1.5.21
    billie@billie-ThinkPad:~/mutt$ tar -jc -f mutt-1.5.21.tar.bz2 mutt-1.5.21/
    billie@billie-ThinkPad:~/mutt$ tar -zc -f mutt-1.5.21.tar.gz mutt-1.5.21/
    billie@billie-ThinkPad:~/mutt$ ls
    mutt-1.5.21  mutt-1.5.21.tar.bz2 mutt-1.5.21.tar.gz
    billie@billie-ThinkPad:~/mutt$ du -m mutt-1.5.21.tar*
    4   mutt-1.5.21.tar.bz2
    5   mutt-1.5.21.tar.gz
    billie@billie-ThinkPad:~/mutt$ file mutt-1.5.21.tar.bz2 mutt-1.5.21.tar.gz 
    mutt-1.5.21.tar.bz2: bzip2 compressed data, block size = 900k
    mutt-1.5.21.tar.gz:  gzip compressed data, from Unix, last modified: Wed ~
    billie@billie-ThinkPad:~/mutt$ 

The option `-jc` means creating a tarball compressed by `bzip2` utility. The
option `-f` specifies the tarball's name. The option `-z` will invoke `gzip`
tool to compress an archive. Obviously, `bzip2` is better than `gzip`. We can
draw a conclusion by comparing the size of the two tarballs. 

    tar -jx -f mutt-1.5.21.tar.bz2
    tar -zx -f mutt-1.5.21.tar.gz

When you get a tarball, you can use the above commands to uncompress it 
according to the name of tarball. More information could be found in man pages. 

Also, you can use `tar` command to backup your files to devices ( a tape):
    
    tar -cv -f /dev/st0 /etc

### crontab command

If you want to execute some periodic tasks, you need to write these tasks to
your crontab file, which is under the `/var/spool/cron/crontab/` directory,
then _cron_ daemon will do these jobs. So how to write a task to the file, you
should use _crontab_ command which maintain _crontab_ files for individual
users, because user's _crontab_ files are not allowed to be edited under that
directory directly.
    
    billie@billie-ThinkPad:/$ crontab -e

After running the command in the first time, display a menu which lists all the 
editors used to edit your crontab file. Select your preferred editor, open the
file. Then add all the tasks to it in terms of syntax, a task per line.

    */5 * * * * touch ~/test

This means to create a file named `test` under your home directory every five
minutes. 
    
    billie@billie-ThinkPad:/$ crontab -l  

The `-l` means to list user's crontab. 

    billie@billie-ThinkPad:/$ crontab -r

The `-r` means to delete user's crontab. 

For more information in detail, you can use the commands below.

    man 5 crontab; man 8 cron; crontab --help

### how to setup bash prompt

When you start linux, it will enter into X mode by default. You open terminal,
start nonlogin shell. In this mode, shell only reads its configuration file
under home directory, which is `~/.bashrc`. So if you want to modify your bash
prompt, you can change the value of environment variable PS1 in this file. 

    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '

The line above is a snippet code from `~/.bashrc`. Now, I want to change the value
of PS1 as the following.

    PS1='${debian_chroot:+($debian_chroot)}\u@\w\$ '
    
After deleting `\h:`, the hostname and semicolon will not display in bash prompt.
Only saving the file is not enough, it doesn't work. Why? Because shell
doesn't know the value of PS1 have been changed. So you have to notify the
shell. At this time, you need to use _source_ command or '.' command to reset
the shell execution environment.
    
    billie@billie-ThinkPad:~$ source ~/.bashrc 
    billie@billie-ThinkPad:~$ . ~/.bashrc
    billie@~$

These two commands have the same effect. The shell prompt changes simpler than
before.

The other shell mode is login shell, which means you should input your usrname
and passward when you start shell. For example, you work on console mode one
of tty0-tty6.

